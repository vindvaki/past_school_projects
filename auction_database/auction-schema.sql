-- NOTE What should be done on delete for users, auctions etc is
-- not always obvious, since bids and deals are data relevant to
-- both sellers and buyers. This problem alone is probably more
-- complicated than the entire assignment and will not be dealt
-- with at this time.

-- NOTE When two contending bids have the same bid_max value, the
-- older bid always wins.

-- NOTE Allow the same user to autobid multiple times on the same
-- auction, since the winning bid is decided at the end of an
-- auction, but the first autobid may not be enough to win. Users
-- should take care, not to compete against themselves.

------------------------------------------------------------------
-- TABLE DEFINITIONS
------------------------------------------------------------------

create table t_payment_method(
    payment_method_id varchar(20),
    primary key (payment_method_id)
);

create table t_user(
    -- Essential info
    user_name varchar(50) not null,
    user_id varchar(20) not null,
    user_password_hash char(32) not null,
    user_email varchar(30) unique not null,
    user_since timestamp not null,

    user_payment_method varchar(20),
    user_payment_details varchar(1000),

    -- Seller info
    seller_info text, 
    seller_payment_method varchar(20),
    seller_payment_details varchar(1000),

    check(
        (seller_info is not null 
            and seller_payment_details is not null
            and seller_payment_method is not null)
        or
        (seller_payment_details is null
            and seller_payment_method is null)
    ),

    primary key (user_id),

    foreign key (user_payment_method)
        references t_payment_method (payment_method_id),
    foreign key (seller_payment_method) 
        references t_payment_method (payment_method_id)
);

create table t_auction(
    -- autogenerated unique id
    auction_id serial,

    auction_seller_id varchar(20) not null,

    -- item info
    --- state: 0 = broken, 1 = works, 2 = great, 3 = new
    --- shipping: 0 = none, 1 = extra fee, 2 = included
    auction_item_label varchar(30) not null,
    auction_item_description text not null,
    auction_item_state integer not null,
    auction_item_location varchar(1000) not null,
    auction_item_shipping integer not null,
    check (
        auction_item_state in (0, 1, 2, 3)
        and auction_item_shipping in (0, 1, 2)
    ),

    -- price
    auction_starting_bid integer not null,
    auction_min_price integer,

    -- duration
    auction_start timestamp not null,
    auction_end timestamp not null, 
    check(auction_start < auction_end),

    foreign key (auction_seller_id) 
        references t_user(user_id) on delete restrict,
    primary key (auction_id)
);

create table t_bid(
    -- autogenerated unique id
    bid_id serial,

    -- t_bid can get updated when raising an automatic bid we argue
    -- that the only relevant bids in a family of autobids are the
    -- original one and the most recent one. Storing any additional
    -- information is redundant since we don't need a public bidding
    -- history on items.

    bid_date timestamp not null,
    bid_original_date timestamp not null,
    check(bid_original_date <= bid_date),
    -- TODO: auction_start <= bid_date <= auction_end

    -- (auction, user) relation
    bid_user varchar(20) not null,
    bid_auction integer not null,

    -- money attribute
    bid_val integer not null,
    bid_min integer not null, 
    bid_max integer not null,
    bid_inc integer not null,
    check (
        bid_min <= bid_val
        and bid_val <= bid_max
        and bid_inc > 0
    ),
    -- NOTE: autobid iff (bid_min < bid_max and bid_inc > 0)

    foreign key (bid_user) references t_user(user_id),
    foreign key (bid_auction) references t_auction(auction_id),
    primary key (bid_id)
);

create table t_category(
    category_id varchar(60),
    primary key (category_id)
);

create table t_auction_category(
    auction_id integer,
    category_id varchar(60),

    foreign key (category_id) 
        references t_category on delete cascade,
    foreign key (auction_id) 
        references t_auction on delete cascade,
    primary key (category_id, auction_id)
);

create table t_deal(
    deal_id serial,
    deal_val integer not null,
    deal_date timestamp not null, 
    user_id varchar(20) not null,
    auction_id integer unique not null,

    -- buyer reviews seller on deal
    seller_rating integer,
    seller_review text, 
    seller_review_date timestamp,
    check((seller_rating is null
            and seller_review is null
            and seller_review_date is null)
        or(seller_rating is not null
            and seller_review is not null
            and seller_review_date is not null)
    ),

    -- seller reviews user on deal
    buyer_rating integer,
    buyer_review text,
    buyer_review_date timestamp,
    check((buyer_rating is null
            and buyer_review is null
            and buyer_review_date is null)
        or(buyer_rating is not null
            and buyer_review is not null
            and buyer_review_date is not null)
    ),

    -- rating constraints
    check (
        0<=buyer_rating and buyer_rating<=10
        and 0<=seller_rating and seller_rating<=10
    ),

    primary key (deal_id),
    foreign key (user_id) 
        references t_user on delete restrict,
    foreign key (auction_id) 
        references t_auction on delete restrict
);

------------------------------------------------------------------
-- FUNCTIONS
------------------------------------------------------------------

-- Current best bid on auction 'id'
create or replace function auction_best_bid(id integer)
returns setof t_bid as $$
begin
    return query
        select * from (
            select * from t_bid
            where bid_max >= all (select bid_max from t_bid)
                and bid_auction = id
            order by bid_original_date asc
        ) as best_candidates
        limit 1;
end;
$$ language plpgsql;

-- PRE: winner and loser are bids such that 
--         winner.bid_max >= loser.bid_max 
--      and, if equal, then 
--         winner.original_date > loser.original_date
-- RETURN: the lowest allowed value x incrementing winner.bid_val
--         above loser.bid_max
create or replace function autobid_newval(
    winner t_bid, loser t_bid
) returns integer as $$
declare
    newval integer;
begin
    newval := winner.bid_val;
    if newval <= loser.bid_max then
        newval := winner.bid_min + 
            + winner.bid_inc 
            * (1 + (loser.bid_max-winner.bid_min)
                    /winner.bid_inc);
        if newval > winner.bid_max then
            newval := winner.bid_max;
        end if;
    end if;
    return newval;
end;
$$ language plpgsql;

-- POST: B has been updated in t_bid with date newdate and value
--       newval.
create or replace function autobid_update( 
    B t_bid, newdate timestamp, newval integer)
returns void as $$
begin
    update t_bid
        set bid_date = newdate,
            bid_val = newval
        where bid_id = B.bid_id;
    return;
end;
$$ language plpgsql;

-- PRE: The only bids competing are the newly inserted one, 'new', 
--      and the previous champion. 
-- POST: A new champion has been decided and t_bid has been updated
--       accordingly
-- RETURN: an updated version of 'new' to correctly reflect the new
--         champion and the contest that occurred.
create or replace function autobid_raise() 
returns trigger as $autobid_raise$
declare
    best t_bid%rowtype;
    newdate timestamp;
    newval integer;
begin
    newdate := new.bid_date;
    select * into best from auction_best_bid(new.bid_auction);
    -- 'best' is the oldest bid having the greatest maximum
    if new.bid_max > best.bid_max then
        -- 'new' bid is better
        newval := autobid_newval(new, best);
        new.bid_val := newval;
        perform autobid_update(best, newdate, best.bid_max);
    elsif new.bid_max <= best.bid_max then
        -- 'best' bid is better 
        newval := autobid_newval(best, new);
        new.bid_val := new.bid_max;
        perform autobid_update(best, newdate, newval); 
    end if;
    new.bid_date := newdate;
    return new;
end;
$autobid_raise$ language plpgsql;

------------------------------------------------------------------
-- TRIGGERS
------------------------------------------------------------------

-- autobid_raise is a row-level before trigger, allowing us to view
-- the table t_bid right before we insert a row and right after all
-- previous rows have been updated; therefore, the precondition for
-- its corresponding trigger function is satisfied each time the
-- function is called.
create trigger autobid_raise before insert on t_bid
    for each row execute procedure autobid_raise();
